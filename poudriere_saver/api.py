import logging
import itertools
import os
import attr
import shutil
from poudriere_saver import option_grammar

LOGGER = logging.getLogger("pty")


@attr.s
class Jail(object):
    name = attr.ib()
    version = attr.ib()
    arch = attr.ib()


@attr.s
class Port(object):
    name = attr.ib()
    path = attr.ib()


def build_filename(jail, port, _set, tail):
    segs = []
    if jail is not None:
        segs.append(jail.name)
    if port is not None:
        segs.append(port.name)
    if _set is not None:
        segs.append(_set)
    segs.append(tail)
    return jail, port, _set, "-".join(segs)


# See man poudriere for informations about file order
def generate_files2(jails, ports, sets, tail):
    yield None, None, None, tail
    # sets
    for s in sets:
        yield build_filename(None, None, s, tail)
    # ports
    for p in ports:
        yield build_filename(None, p, None, tail)
    # jail
    for j in jails:
        yield build_filename(j, None, None, tail)
    # ports sets
    for p, s in itertools.product(ports, sets):
        yield build_filename(None, p, s, tail)
    # jails ports
    for j, p in itertools.product(jails, ports):
        yield build_filename(j, p, None, tail)
    # jails sets
    for j, s in itertools.product(jails, sets):
        yield build_filename(j, None, s, tail)
    # jails ports sets
    for j, p, s in itertools.product(jails, ports, sets):
        yield build_filename(j, p, s, tail)


# Same thing, but build absolute path, and drop those that don't exists
def generate_files(root_dir, j, p, s, t):
    for j, p, s, f in generate_files2(j, p, s, t):
        path = os.path.join(root_dir, f)
        if os.path.exists(path):
            yield j, p, s, os.path.abspath(path)


def generate_options_files(r, j, p, s):
    return reversed(tuple(generate_files(r, j, p, s, "options")))


def generate_make_conf_files(r, j, p, s):
    return generate_files(r, j, p, s, "make.conf")


# Same thing with blacklist, poudriere


# Load every option in this directory
# Return a dictionnary of category, where every element is a port
def load_option_directories(option_dir):
    LOGGER.debug("Load option directory %s", option_dir)
    res = {}
    for dir_name in os.listdir(option_dir):
        split = dir_name.split("_")
        category = split[0]
        name = "_".join(split[1:])
        opt_file = os.path.join(option_dir, dir_name, "options")
        if os.path.isfile(opt_file):
            LOGGER.debug(
                "Load port %s/%s configuration from %s", category, name, opt_file
            )
            with open(opt_file) as fd:
                c = option_grammar.parse(fd)
            if category not in res:
                res[category] = {name: c}
            else:
                res[category][name] = c
        else:
            LOGGER.warning("%s no such file in %s", opt_file, option_dir)
    return res


# Load options from this directory
def load_options(root_dir, jails, ports, sets):
    LOGGER.debug("Load options files from %s", root_dir)
    opts = []
    opt_files = generate_options_files(root_dir, jails, ports, sets)
    for jail, port, _set, opt_dir in opt_files:
        opt = {}
        if jail is not None:
            opt["jail"] = attr.asdict(jail)
        if port is not None:
            opt["tree"] = attr.asdict(port)
        if _set is not None:
            opt["set"] = _set
        opt["ports"] = load_option_directories(opt_dir)
        opts.append(opt)
    return opts


def load_make_conf_files(root_dir, jails, ports, sets):
    LOGGER.debug("Load make.conf from %s", root_dir)
    conf = []
    conf_files = generate_make_conf_files(root_dir, jails, ports, sets)
    for jail, port, _set, make_conf in conf_files:
        c = {}
        if jail is not None:
            c["jail"] = attr.asdict(jail)
        if port is not None:
            c["tree"] = attr.asdict(port)
        if _set is not None:
            c["set"] = _set
        LOGGER.debug("Load configuration file %s", make_conf)
        with open(make_conf) as conf_fd:
            c["conf"] = option_grammar.parse(conf_fd)
        conf.append(c)
    return conf


def write_conf_file(path, conf):
    def write(l):
        fd.write(l + "\n")

    with open(path, "w") as fd:
        write("# This file was generated by poudriere_saver")
        # For now, only one operator is supported
        for o, values in conf.items():
            for v in values:
                write(f"{o}+={v}")


def write_port_options(parent_dir, category, port, conf):
    pdir_name = f"{category}_{port}"
    pdir_path = os.path.join(parent_dir, pdir_name)
    pconf_path = os.path.join(pdir_path, "options")
    LOGGER.debug("Create port %s/%s configurations", category, port)
    os.mkdir(pdir_path)
    write_conf_file(pconf_path, conf)


def get_segment_filename(segment, tail):
    if "jail" in segment:
        jail = Jail(
            segment["jail"]["name"], segment["jail"]["version"], segment["jail"]["arch"]
        )
    else:
        jail = None
    if "tree" in segment:
        port = Port(segment["tree"]["name"], segment["tree"]["path"])
    else:
        port = None
    _set = segment.get("set", None)
    _, _, _, name = build_filename(jail, port, _set, tail)
    return name


def write_options(conf, dest_dir):
    LOGGER.debug("Write options files in %s", dest_dir)
    for seg in conf:
        dir_path = os.path.join(dest_dir, get_segment_filename(seg, "options"))
        # If this directory exists, drop it
        if os.path.exists(dir_path):
            LOGGER.warning("Delete previous %s", dir_path)
            shutil.rmtree(dir_path)
        else:
            LOGGER.debug("Create %s", dir_path)
        os.makedirs(dir_path)
        for category in seg.get("ports", {}):
            for port, c in seg["ports"][category].items():
                write_port_options(dir_path, category, port, c)


def write_make_conf(conf, dest_dir):
    LOGGER.debug("Write make.conf files in %s", dest_dir)
    for seg in conf:
        file_path = os.path.join(dest_dir, get_segment_filename(seg, "make.conf"))
        LOGGER.debug("Write %s", file_path)
        write_conf_file(file_path, seg["conf"])
